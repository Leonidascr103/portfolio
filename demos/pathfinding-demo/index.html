<!DOCTYPE html>
<html>
<head>
    <title>Pathfinding Demo</title>
    <style>
        body { font-family: Arial; padding: 20px; max-width: 800px; margin: 0 auto; }
        #grid { display: grid; grid-template-columns: repeat(20, 25px); gap: 1px; }
        .cell { width: 25px; height: 25px; border: 1px solid #ccc; cursor: pointer; }
        .wall { background: #333; }
        .start { background: #4ade80; }
        .end { background: #f87171; }
        .path { background: #fbbf24; }
        .open { background: #60a5fa; }
        button { margin: 10px 5px; padding: 10px 20px; background: #0ea5e9; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #0284c7; }
        .controls { margin-bottom: 20px; }
    </style>
</head>
<body>
    <h2>Demo: Algoritmo A* Pathfinding</h2>
    <div class="controls">
        <button onclick="startSearch()">‚ñ∂Ô∏è Iniciar B√∫squeda</button>
        <button onclick="clearPath()">üóëÔ∏è Limpiar Camino</button>
        <button onclick="randomWalls()">üé≤ Paredes Aleatorias</button>
    </div>
    <p><strong>Instrucciones:</strong> Click en celdas para poner/quitar paredes. Verde=Inicio, Rojo=Fin, Amarillo=Camino √≥ptimo.</p>
    <div id="grid"></div>
    <p id="info" style="margin-top: 20px;">Nodos explorados: 0 | Tiempo: 0ms</p>

    <script>
        // Implementaci√≥n simple de A*
        const GRID_SIZE = 20;
        let grid = [];
        let start = {x: 2, y: 2};
        let end = {x: 17, y: 17};

        function initGrid() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            grid = [];
            for(let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for(let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${x}-${y}`;
                    cell.onclick = () => toggleWall(x, y);
                    gridEl.appendChild(cell);
                    grid[y][x] = {x, y, wall: false, g: 0, h: 0, parent: null};
                }
            }
            updateCell(start.x, start.y, 'start');
            updateCell(end.x, end.y, 'end');
        }

        function updateCell(x, y, className) {
            const cell = document.getElementById(`cell-${x}-${y}`);
            cell.className = `cell ${className}`;
        }

        function toggleWall(x, y) {
            if((x === start.x && y === start.y) || (x === end.x && y === end.y)) return;
            grid[y][x].wall = !grid[y][x].wall;
            updateCell(x, y, grid[y][x].wall ? 'wall' : '');
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function startSearch() {
            clearPath();
            const openSet = [grid[start.y][start.x]];
            const closedSet = [];
            const startTime = performance.now();
            let nodesExplored = 0;

            while(openSet.length > 0) {
                openSet.sort((a, b) => (a.g + a.h) - (b.g + b.h));
                const current = openSet.shift();
                closedSet.push(current);
                nodesExplored++;

                if(current.x === end.x && current.y === end.y) {
                    const path = [];
                    let temp = current;
                    while(temp.parent) {
                        path.push(temp);
                        temp = temp.parent;
                    }
                    path.forEach(p => updateCell(p.x, p.y, 'path'));
                    updateCell(start.x, start.y, 'start');
                    updateCell(end.x, end.y, 'end');
                    const time = (performance.now() - startTime).toFixed(2);
                    document.getElementById('info').textContent = `Nodos explorados: ${nodesExplored} | Tiempo: ${time}ms`;
                    return;
                }

                const neighbors = [
                    {x: current.x + 1, y: current.y},
                    {x: current.x - 1, y: current.y},
                    {x: current.x, y: current.y + 1},
                    {x: current.x, y: current.y - 1}
                ];

                neighbors.forEach(n => {
                    if(n.x < 0 || n.x >= GRID_SIZE || n.y < 0 || n.y >= GRID_SIZE) return;
                    if(grid[n.y][n.x].wall || closedSet.includes(grid[n.y][n.x])) return;

                    const tentativeG = current.g + 1;
                    if(!openSet.includes(grid[n.y][n.x]) || tentativeG < grid[n.y][n.x].g) {
                        grid[n.y][n.x].g = tentativeG;
                        grid[n.y][n.x].h = heuristic(grid[n.y][n.x], grid[end.y][end.x]);
                        grid[n.y][n.x].parent = current;
                        if(!openSet.includes(grid[n.y][n.x])) {
                            openSet.push(grid[n.y][n.x]);
                            updateCell(n.x, n.y, 'open');
                        }
                    }
                });
            }
        }

        function clearPath() {
            for(let y = 0; y < GRID_SIZE; y++) {
                for(let x = 0; x < GRID_SIZE; x++) {
                    if(!grid[y][x].wall && !(x === start.x && y === start.y) && !(x === end.x && y === end.y)) {
                        updateCell(x, y, '');
                    }
                }
            }
        }

        function randomWalls() {
            clearPath();
            for(let y = 0; y < GRID_SIZE; y++) {
                for(let x = 0; x < GRID_SIZE; x++) {
                    if(Math.random() < 0.2 && !(x === start.x && y === start.y) && !(x === end.x && y === end.y)) {
                        grid[y][x].wall = true;
                        updateCell(x, y, 'wall');
                    }
                }
            }
        }

        initGrid();
    </script>
</body>
</html>